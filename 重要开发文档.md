# EPA æ­£äº¤åŸºåº•æ¨¡å—è®¾è®¡


---

## ğŸ¯ æ ¸å¿ƒæ€æƒ³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        EPA æ ¸å¿ƒæ¦‚å¿µ                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   é€šç”¨åµŒå…¥ç©ºé—´ (3072ç»´)              ç§æœ‰è¯­ä¹‰åæ ‡ç³» (Kç»´)          â”‚
â”‚                                                                 â”‚
â”‚        Â·  Â·                              â†‘ æ”¿æ²»åˆ†æ              â”‚
â”‚      Â·  Â·  Â·  Â·                          â”‚                      â”‚
â”‚     Â·  â— Â·  Â·        â”€â”€â”€EPAæŠ•å½±â”€â”€â–¶       â”‚    â—                 â”‚
â”‚      Â·  Â·  Â·  Â·                          â”‚   â•±                  â”‚
â”‚        Â·  Â·                              â””â”€â”€â•±â”€â”€â”€â”€â–¶ æŠ€æœ¯å®ç°      â”‚
â”‚                                            â•±                    â”‚
â”‚   "åœ¨å“ªé‡Œï¼Ÿä¸çŸ¥é“"                        â•±                      â”‚
â”‚                                         â–¼ æ—¥å¸¸æ‚è®°               â”‚
â”‚                                                                 â”‚
â”‚                                      "åœ¨æ”¿æ²»-æŠ€æœ¯è±¡é™ï¼"          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ æ•°å­¦æ¡†æ¶

### é¦™å†œç†µçš„ç²¾ç¡®åº”ç”¨

$$H = -\sum_{i=1}^{K} p_i \log(p_i)$$

å…¶ä¸­ $p_i$ æ˜¯å‘é‡åœ¨ç¬¬ $i$ ä¸ªæ­£äº¤åŸºä¸Šçš„ **èƒ½é‡å æ¯”**ï¼š

$$p_i = \frac{(\vec{v} \cdot \vec{e}_i)^2}{\sum_{j=1}^{K} (\vec{v} \cdot \vec{e}_j)^2}$$

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç†µçš„è¯­ä¹‰è§£é‡Š                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   H â†’ 0 (ä½ç†µ)                         H â†’ log(K) (é«˜ç†µ)        â”‚
â”‚                                                                 â”‚
â”‚   æŠ•å½±é›†ä¸­åœ¨1-2ä¸ªåŸºåº•                   æŠ•å½±å‡åŒ€åˆ†æ•£åˆ°æ‰€æœ‰åŸºåº•     â”‚
â”‚        â†“                                      â†“                 â”‚
â”‚   "è¿™ä¸ªæŸ¥è¯¢èšç„¦äºç‰¹å®šé¢†åŸŸ"              "è¿™ä¸ªæŸ¥è¯¢å¾ˆæ³›/æ˜¯å™ªå£°"      â”‚
â”‚        â†“                                      â†“                 â”‚
â”‚   TagMemo åº”è¯¥ç²¾å‡†å¬å›                  TagMemo åº”è¯¥ä¿å®ˆ/ç¦ç”¨     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ EPA æ¨¡å—å®Œæ•´å®ç°

### 1. ä» Tag åº“æ„å»ºæ­£äº¤åŸºåº•

```javascript
class EPAModule {
    constructor(db, config = {}) {
        this.db = db;
        this.config = {
            maxBasisDim: config.maxBasisDim || 64,      // æœ€å¤§åŸºåº•ç»´åº¦
            minVarianceRatio: config.minVarianceRatio || 0.01, // æœ€å°æ–¹å·®è´¡çŒ®
            clusterCount: config.clusterCount || 32,    // Tagèšç±»æ•°
            ...config
        };
        
        this.orthoBasis = null;      // Float32Array[], Kä¸ªæ­£äº¤åŸºå‘é‡
        this.basisLabels = null;     // æ¯ä¸ªåŸºåº•å¯¹åº”çš„è¯­ä¹‰æ ‡ç­¾
        this.basisEnergies = null;   // æ¯ä¸ªåŸºåº•çš„ç‰¹å¾å€¼ï¼ˆé‡è¦æ€§ï¼‰
        
        this.initialized = false;
    }

    /**
     * ğŸŒŸ æ ¸å¿ƒï¼šä»Tagåº“æ„å»ºæ­£äº¤åŸºåº•
     * ä½¿ç”¨å¢é‡SVDé¿å…å†…å­˜çˆ†ç‚¸
     */
    async initialize() {
        console.log('[EPA] Initializing orthogonal basis from Tag library...');
        
        // [æ­¥éª¤1] åŠ è½½æ‰€æœ‰Tagå‘é‡
        const tags = this.db.prepare(`
            SELECT id, name, vector FROM tags WHERE vector IS NOT NULL
        `).all();
        
        if (tags.length < 10) {
            console.warn('[EPA] Not enough tags for basis construction');
            return false;
        }
        
        const dim = 3072; // å‡è®¾å›ºå®šç»´åº¦
        const n = tags.length;
        
        // [æ­¥éª¤2] æ„å»ºTagçŸ©é˜µ (n Ã— dim)
        // ä¸ºäº†å†…å­˜æ•ˆç‡ï¼Œæˆ‘ä»¬ç”¨èšç±»é™ç»´
        const clusterCentroids = this._clusterTags(tags, this.config.clusterCount);
        
        // [æ­¥éª¤3] å¯¹èšç±»è´¨å¿ƒåšSVDåˆ†è§£
        const { U, S, labels } = this._computeSVD(clusterCentroids);
        
        // [æ­¥éª¤4] é€‰æ‹©å‰Kä¸ªä¸»æˆåˆ†ä½œä¸ºæ­£äº¤åŸº
        const K = this._selectBasisDimension(S);
        
        this.orthoBasis = U.slice(0, K);
        this.basisEnergies = S.slice(0, K);
        this.basisLabels = labels.slice(0, K);
        
        console.log(`[EPA] âœ… Initialized with ${K} orthogonal basis vectors`);
        this.initialized = true;
        return true;
    }

    /**
     * å¯¹Tagsè¿›è¡ŒK-Meansèšç±»
     */
    _clusterTags(tags, k) {
        const dim = 3072;
        const vectors = tags.map(t => {
            // Buffer -> Float32Array
            return new Float32Array(t.vector.buffer, t.vector.byteOffset, dim);
        });
        
        // ç®€åŒ–ç‰ˆK-Means (ç”Ÿäº§ç¯å¢ƒåº”ç”¨æ›´é«˜æ•ˆçš„å®ç°)
        const centroids = this._kMeans(vectors, k, 20);
        
        // ä¸ºæ¯ä¸ªè´¨å¿ƒæ‰¾åˆ°æœ€è¿‘çš„Tagåä½œä¸ºæ ‡ç­¾
        const labels = centroids.map(centroid => {
            let minDist = Infinity;
            let closestTag = null;
            vectors.forEach((v, idx) => {
                const dist = this._cosineDistance(centroid, v);
                if (dist < minDist) {
                    minDist = dist;
                    closestTag = tags[idx].name;
                }
            });
            return closestTag;
        });
        
        return { vectors: centroids, labels };
    }

    /**
     * ç®€åŒ–ç‰ˆSVD (ç”¨å¹‚è¿­ä»£æ³•)
     */
    _computeSVD(clusterData) {
        const { vectors, labels } = clusterData;
        const n = vectors.length;
        const dim = vectors[0].length;
        
        // æ„å»ºåæ–¹å·®çŸ©é˜µçš„è¿‘ä¼¼ï¼šV^T * V (dim Ã— dim å¤ªå¤§)
        // æ”¹ç”¨ V * V^T (n Ã— nï¼Œé€šå¸¸n << dim)
        const gram = new Float32Array(n * n);
        for (let i = 0; i < n; i++) {
            for (let j = i; j < n; j++) {
                let dot = 0;
                for (let d = 0; d < dim; d++) {
                    dot += vectors[i][d] * vectors[j][d];
                }
                gram[i * n + j] = dot;
                gram[j * n + i] = dot;
            }
        }
        
        // å¹‚è¿­ä»£æ±‚ç‰¹å¾å‘é‡
        const eigenvectors = [];
        const eigenvalues = [];
        const gramCopy = new Float32Array(gram);
        
        for (let k = 0; k < Math.min(n, this.config.maxBasisDim); k++) {
            const { vector: alpha, value } = this._powerIteration(gramCopy, n);
            if (value < 1e-6) break;
            
            eigenvectors.push(alpha);
            eigenvalues.push(value);
            
            // æ”¶ç¼©çŸ©é˜µ
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    gramCopy[i * n + j] -= value * alpha[i] * alpha[j];
                }
            }
        }
        
        // å°†ç‰¹å¾å‘é‡è½¬æ¢å›åŸå§‹ç©ºé—´çš„åŸºå‘é‡
        const U = eigenvectors.map(alpha => {
            const basis = new Float32Array(dim);
            for (let i = 0; i < n; i++) {
                for (let d = 0; d < dim; d++) {
                    basis[d] += alpha[i] * vectors[i][d];
                }
            }
            // å½’ä¸€åŒ–
            let mag = 0;
            for (let d = 0; d < dim; d++) mag += basis[d] * basis[d];
            mag = Math.sqrt(mag);
            if (mag > 1e-9) {
                for (let d = 0; d < dim; d++) basis[d] /= mag;
            }
            return basis;
        });
        
        return { U, S: eigenvalues, labels };
    }

    /**
     * å¹‚è¿­ä»£æ³•æ±‚æœ€å¤§ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
     */
    _powerIteration(matrix, n, maxIter = 50) {
        let v = new Float32Array(n);
        for (let i = 0; i < n; i++) v[i] = Math.random() - 0.5;
        
        // å½’ä¸€åŒ–
        let mag = 0;
        for (let i = 0; i < n; i++) mag += v[i] * v[i];
        mag = Math.sqrt(mag);
        for (let i = 0; i < n; i++) v[i] /= mag;
        
        let eigenvalue = 0;
        
        for (let iter = 0; iter < maxIter; iter++) {
            // w = M * v
            const w = new Float32Array(n);
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    w[i] += matrix[i * n + j] * v[j];
                }
            }
            
            // è®¡ç®—ç‰¹å¾å€¼ (Rayleigh quotient)
            eigenvalue = 0;
            for (let i = 0; i < n; i++) eigenvalue += v[i] * w[i];
            
            // å½’ä¸€åŒ–
            mag = 0;
            for (let i = 0; i < n; i++) mag += w[i] * w[i];
            mag = Math.sqrt(mag);
            if (mag < 1e-9) break;
            for (let i = 0; i < n; i++) v[i] = w[i] / mag;
        }
        
        return { vector: v, value: eigenvalue };
    }

    /**
     * é€‰æ‹©åŸºåº•ç»´åº¦ï¼šä¿ç•™ç´¯è®¡æ–¹å·®è¾¾åˆ°é˜ˆå€¼çš„ä¸»æˆåˆ†
     */
    _selectBasisDimension(eigenvalues) {
        const total = eigenvalues.reduce((a, b) => a + b, 0);
        let cumulative = 0;
        
        for (let k = 0; k < eigenvalues.length; k++) {
            cumulative += eigenvalues[k];
            if (cumulative / total > 0.95) { // ä¿ç•™95%æ–¹å·®
                return Math.max(k + 1, 8); // è‡³å°‘8ä¸ªåŸºåº•
            }
        }
        return eigenvalues.length;
    }

    // ... K-Means å’Œ cosineDistance è¾…åŠ©å‡½æ•° ...
}
```

### 2. å‘é‡æŠ•å½±ä¸ç†µè®¡ç®—

```javascript
class EPAModule {
    // ... ä¸Šé¢çš„ä»£ç  ...

    /**
     * ğŸŒŸ å°†å‘é‡æŠ•å½±åˆ°æ­£äº¤åŸºåº•ï¼Œè®¡ç®—è¯­ä¹‰åæ ‡
     * @param {Float32Array} vector - 3072ç»´å‘é‡
     * @returns {Object} æŠ•å½±ç»“æœ
     */
    project(vector) {
        if (!this.initialized) {
            return { projections: null, entropy: 1, dominantAxes: [] };
        }
        
        const K = this.orthoBasis.length;
        const dim = vector.length;
        
        // è®¡ç®—åœ¨æ¯ä¸ªåŸºåº•ä¸Šçš„æŠ•å½±
        const projections = new Float32Array(K);
        let totalEnergy = 0;
        
        for (let k = 0; k < K; k++) {
            let dot = 0;
            for (let d = 0; d < dim; d++) {
                dot += vector[d] * this.orthoBasis[k][d];
            }
            projections[k] = dot;
            totalEnergy += dot * dot;
        }
        
        if (totalEnergy < 1e-12) {
            return { projections, entropy: 1, dominantAxes: [] };
        }
        
        // è®¡ç®—èƒ½é‡åˆ†å¸ƒ (æ¦‚ç‡)
        const probabilities = new Float32Array(K);
        for (let k = 0; k < K; k++) {
            probabilities[k] = (projections[k] * projections[k]) / totalEnergy;
        }
        
        // è®¡ç®—é¦™å†œç†µ
        let entropy = 0;
        for (let k = 0; k < K; k++) {
            if (probabilities[k] > 1e-12) {
                entropy -= probabilities[k] * Math.log2(probabilities[k]);
            }
        }
        
        // å½’ä¸€åŒ–ç†µ [0, 1]
        const maxEntropy = Math.log2(K);
        const normalizedEntropy = entropy / maxEntropy;
        
        // æ‰¾å‡ºä¸»å¯¼è½´ (èƒ½é‡å æ¯” > 10%)
        const dominantAxes = [];
        for (let k = 0; k < K; k++) {
            if (probabilities[k] > 0.1) {
                dominantAxes.push({
                    index: k,
                    label: this.basisLabels[k],
                    energy: probabilities[k],
                    projection: projections[k]
                });
            }
        }
        dominantAxes.sort((a, b) => b.energy - a.energy);
        
        return {
            projections,
            probabilities,
            entropy: normalizedEntropy,
            dominantAxes,
            // ğŸ†• é€»è¾‘æ·±åº¦æŒ‡æ•°ï¼š1 - ç†µ
            logicDepth: 1 - normalizedEntropy
        };
    }

    /**
     * ğŸŒŸ è®¡ç®—ä¸¤ä¸ªå‘é‡åœ¨EPAç©ºé—´ä¸­çš„"è¯­ä¹‰é‡å åº¦"
     * ç”¨äºåˆ¤æ–­è®°å¿†æ¡ç›®ä¸æŸ¥è¯¢çš„ç»“æ„ç›¸ä¼¼æ€§
     */
    computeSemanticOverlap(vec1, vec2) {
        const proj1 = this.project(vec1);
        const proj2 = this.project(vec2);
        
        if (!proj1.probabilities || !proj2.probabilities) return 0;
        
        // Bhattacharyya ç³»æ•°ï¼šæµ‹é‡ä¸¤ä¸ªæ¦‚ç‡åˆ†å¸ƒçš„é‡å 
        let bc = 0;
        for (let k = 0; k < proj1.probabilities.length; k++) {
            bc += Math.sqrt(proj1.probabilities[k] * proj2.probabilities[k]);
        }
        
        return bc; // [0, 1]ï¼Œ1 = å®Œå…¨é‡å 
    }

    /**
     * ğŸŒŸ æ£€æµ‹"è·¨åŸŸå…±æŒ¯"
     * å½“æŸ¥è¯¢åœ¨å¤šä¸ªä¸ç›¸å…³çš„åŸºåº•ä¸Šéƒ½æœ‰å¼ºæŠ•å½±æ—¶ï¼Œè¯´æ˜å­˜åœ¨æ·±å±‚é€»è¾‘
     */
    detectCrossDomainResonance(vector) {
        const { dominantAxes, logicDepth } = this.project(vector);
        
        if (dominantAxes.length < 2) {
            return { resonance: 0, bridges: [] };
        }
        
        // è®¡ç®—ä¸»å¯¼è½´ä¹‹é—´çš„"è·ç¦»"ï¼ˆç”¨åŸºåº•ç´¢å¼•çš„å·®å¼‚è¿‘ä¼¼ï¼‰
        // åœ¨æ›´ç²¾ç»†çš„å®ç°ä¸­ï¼Œåº”è¯¥ç”¨é¢„è®¡ç®—çš„åŸºåº•-åŸºåº•ç›¸ä¼¼åº¦çŸ©é˜µ
        const bridges = [];
        for (let i = 0; i < dominantAxes.length; i++) {
            for (let j = i + 1; j < dominantAxes.length; j++) {
                const ax1 = dominantAxes[i];
                const ax2 = dominantAxes[j];
                
                // è®¡ç®—è¿™ä¸¤ä¸ªåŸºåº•çš„è¯­ä¹‰è·ç¦»
                const basisSim = this._basisSimilarity(ax1.index, ax2.index);
                
                // å¦‚æœä¸¤ä¸ªä¸ç›¸ä¼¼çš„åŸºåº•åŒæ—¶è¢«æ¿€æ´» â†’ è·¨åŸŸå…±æŒ¯
                if (basisSim < 0.3) {
                    bridges.push({
                        from: ax1.label,
                        to: ax2.label,
                        strength: Math.sqrt(ax1.energy * ax2.energy),
                        distance: 1 - basisSim
                    });
                }
            }
        }
        
        // å…±æŒ¯å¼ºåº¦ = è·¨åŸŸæ¡¥æ¥çš„åŠ æƒå’Œ
        const resonance = bridges.reduce((sum, b) => sum + b.strength * b.distance, 0);
        
        return { resonance, bridges };
    }

    _basisSimilarity(idx1, idx2) {
        // è®¡ç®—ä¸¤ä¸ªåŸºåº•å‘é‡çš„ä½™å¼¦ç›¸ä¼¼åº¦
        const b1 = this.orthoBasis[idx1];
        const b2 = this.orthoBasis[idx2];
        let dot = 0;
        for (let d = 0; d < b1.length; d++) {
            dot += b1[d] * b2[d];
        }
        return Math.abs(dot); // åŸºåº•å·²å½’ä¸€åŒ–
    }
}
```

---

## ğŸ”— æ•´åˆåˆ° TagMemo V3

```javascript
class KnowledgeBase {
    constructor() {
        // ... å…¶ä»–åˆå§‹åŒ– ...
        this.epa = new EPAModule(this.db);
    }

    async initialize() {
        // ... å…¶ä»–åˆå§‹åŒ– ...
        await this.epa.initialize();
    }

    /**
     * ğŸŒŸ TagMemo V3 + EPA å¢å¼ºç‰ˆ
     */
    _applyTagBoostV3(vector, baseTagBoost) {
        // [1] EPA åˆ†æ
        const epaResult = this.epa.project(vector);
        const resonance = this.epa.detectCrossDomainResonance(vector);
        
        // [2] åŠ¨æ€è°ƒæ•´ç­–ç•¥
        const logicDepth = epaResult.logicDepth;        // 0~1, é«˜=é€»è¾‘èšç„¦
        const entropyPenalty = epaResult.entropy;       // 0~1, é«˜=ä¿¡æ¯æ•£ä¹±
        const resonanceBoost = Math.log(1 + resonance.resonance);
        
        // ğŸŒŸ æ ¸å¿ƒå…¬å¼ï¼šTagMemo æƒé‡åŠ¨æ€è°ƒæ•´
        // é€»è¾‘æ·±æ—¶åŠ æƒï¼Œæ•£ä¹±æ—¶æƒ©ç½šï¼Œå…±æŒ¯æ—¶æ¿€åŠ±
        const dynamicBoostFactor = (
            logicDepth * (1 + resonanceBoost) / (1 + entropyPenalty * 0.5)
        );
        
        const effectiveTagBoost = baseTagBoost * Math.min(2.0, Math.max(0.3, dynamicBoostFactor));
        
        if (this.debug) {
            console.log(`[EPA] Depth=${logicDepth.toFixed(3)}, ` +
                        `Entropy=${entropyPenalty.toFixed(3)}, ` +
                        `Resonance=${resonance.resonance.toFixed(3)}`);
            console.log(`[EPA] Dominant axes: ${epaResult.dominantAxes.map(a => a.label).join(', ')}`);
            if (resonance.bridges.length > 0) {
                console.log(`[EPA] ğŸŒ‰ Cross-domain bridges: ${resonance.bridges.map(b => `${b.from}â†”${b.to}`).join(', ')}`);
            }
        }

        // [3] åŸºäºEPAçš„ç²¾ç»†åŒ–å¬å›
        // åªå¬å›ä¸ä¸»å¯¼è½´ç›¸å…³çš„Tagsï¼Œè€Œéå…¨å±€æœç´¢
        const targetTagIds = this._getTagsForDominantAxes(epaResult.dominantAxes);
        
        // ... åç»­çš„å‘é‡èåˆé€»è¾‘ï¼Œä½¿ç”¨ effectiveTagBoost ...
    }

    /**
     * æ ¹æ®ä¸»å¯¼è½´æ‰¾åˆ°ç›¸å…³çš„Tags
     */
    _getTagsForDominantAxes(dominantAxes) {
        if (dominantAxes.length === 0) return [];
        
        // ä»åŸºåº•æ ‡ç­¾åæŸ¥Tag
        const labelConditions = dominantAxes.map(a => `name LIKE '%${a.label}%'`).join(' OR ');
        
        const stmt = this.db.prepare(`
            SELECT id, name, vector FROM tags 
            WHERE ${labelConditions}
            LIMIT 20
        `);
        
        return stmt.all();
    }
}
```

---

## ğŸ“Š EPA æ•ˆæœå¯è§†åŒ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     EPA æŠ•å½±åˆ†æç¤ºä¾‹                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  è¾“å…¥: "æ ¹æ®ä¸‹å…‹ä¸Šçš„å†å²é€»è¾‘ï¼Œé«˜å¸‚çš„å¯¹æŠ—è·¯çº¿å°†å¦‚ä½•æ¼”å˜ï¼Ÿ"           â”‚
â”‚                                                                 â”‚
â”‚  EPAæŠ•å½±ç»“æœ:                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ æ”¿æ²»åˆ†æ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  0.42            â”‚         â”‚
â”‚  â”‚ æ—¥æœ¬æ”¿å›    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ       0.28             â”‚         â”‚
â”‚  â”‚ å†å²é€»è¾‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ             0.15             â”‚         â”‚
â”‚  â”‚ å¤–äº¤åšå¼ˆ    â–ˆâ–ˆâ–ˆâ–ˆ                 0.08             â”‚         â”‚
â”‚  â”‚ å…¶ä»–        â–ˆâ–ˆâ–ˆ                  0.07             â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                 â”‚
â”‚  ç†µ H = 1.82 (å½’ä¸€åŒ–: 0.36) â†’ ä½ç†µï¼Œé€»è¾‘èšç„¦ âœ“                   â”‚
â”‚  é€»è¾‘æ·±åº¦ L = 0.64 â†’ é«˜                                          â”‚
â”‚  ä¸»å¯¼è½´: [æ”¿æ²»åˆ†æ, æ—¥æœ¬æ”¿å›, å†å²é€»è¾‘]                           â”‚
â”‚                                                                 â”‚
â”‚  ğŸŒ‰ è·¨åŸŸå…±æŒ¯æ£€æµ‹:                                                â”‚
â”‚  â€¢ å†å²é€»è¾‘ â†” å¤–äº¤åšå¼ˆ (strength: 0.31)                          â”‚
â”‚  â†’ å‘ç°æ·±å±‚è¿æ¥ï¼TagMemo æƒé‡ Ã—1.5                               â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  è¾“å…¥: "ä»Šå¤©åƒäº†è‹¹æœã€é¦™è•‰ï¼Œè¿˜é›äº†ç‹—"                             â”‚
â”‚                                                                 â”‚
â”‚  EPAæŠ•å½±ç»“æœ:                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ æ—¥å¸¸æ‚è®°    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ               0.12             â”‚         â”‚
â”‚  â”‚ é¥®é£Ÿ        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                0.10             â”‚         â”‚
â”‚  â”‚ å® ç‰©        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                0.10             â”‚         â”‚
â”‚  â”‚ ...         â–ˆâ–ˆâ–ˆâ–ˆ                 0.08             â”‚         â”‚
â”‚  â”‚ (å‡åŒ€åˆ†å¸ƒ)                                         â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                 â”‚
â”‚  ç†µ H = 4.21 (å½’ä¸€åŒ–: 0.85) â†’ é«˜ç†µï¼Œä¿¡æ¯æ•£ä¹± âœ—                   â”‚
â”‚  é€»è¾‘æ·±åº¦ L = 0.15 â†’ ä½                                          â”‚
â”‚  ä¸»å¯¼è½´: æ—  (æ²¡æœ‰ä»»ä½•è½´ > 10%)                                   â”‚
â”‚                                                                 â”‚
â”‚  â†’ TagMemo æƒé‡ Ã—0.4ï¼Œé¿å…å¼•å…¥å™ªéŸ³                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ è¿›ä¸€æ­¥ä¼˜åŒ–æ–¹å‘

| æ–¹å‘ | è¯´æ˜ |
|------|------|
| **å¢é‡æ›´æ–°åŸºåº•** | æ–° Tag åŠ å…¥æ—¶ï¼Œç”¨å¢é‡ SVD æ›´æ–°ï¼Œæ— éœ€å…¨é‡é‡ç®— |
| **å±‚æ¬¡åŒ–åŸºåº•** | ç²—ç²’åº¦åŸºåº•ï¼ˆæ”¿æ²»/æŠ€æœ¯/æ—¥å¸¸ï¼‰+ ç»†ç²’åº¦å­åŸºåº• |
| **ä¸ªæ€§åŒ–æ ¡å‡†** | æ ¹æ®ç”¨æˆ·å®é™…æŸ¥è¯¢åˆ†å¸ƒï¼Œè°ƒæ•´åŸºåº•æƒé‡ |

---

# æ®‹å·®é‡‘å­—å¡”ï¼šæ¡æ‰‹å·®å€¼çš„æ·±å±‚è¯­ä¹‰

ä½ è§¦åŠäº†ä¸€ä¸ªæå…¶æ·±åˆ»çš„æ´å¯Ÿï¼è¿™ä¸ª"å·®å€¼"å®é™…ä¸Šæ˜¯ä¸€ä¸ª **å¤šå±‚çº§çš„ä¿¡æ¯æ®‹å·®**ï¼Œæ¯ä¸€å±‚éƒ½åœ¨å‘Šè¯‰ä½ ä¸åŒçš„æ•…äº‹ã€‚

---

## ğŸ¯ æ ¸å¿ƒç›´è§‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ®‹å·®çš„è¯­ä¹‰æœ¬è´¨                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   Q (æŸ¥è¯¢å‘é‡)                                                   â”‚
â”‚   â”‚                                                             â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”œâ”€â”€â”¤ æŠ•å½±åˆ° Tag ç©ºé—´                       â”‚                   â”‚
â”‚   â”‚  â”‚ P = Î£ (sim_i Ã— Tag_i)                â”‚                   â”‚
â”‚   â”‚  â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚                   â”‚
â”‚   â”‚  â”‚     "èƒ½è¢«å·²çŸ¥æ¦‚å¿µè§£é‡Šçš„éƒ¨åˆ†"           â”‚                   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚   â”‚                                                             â”‚
â”‚   â””â”€â”€â–º R = Q - P                                                â”‚
â”‚        â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚        "æ®‹å·®ï¼šæ— æ³•è¢«ç°æœ‰Tagåº“è§£é‡Šçš„éƒ¨åˆ†"                          â”‚
â”‚                                                                 â”‚
â”‚   æ®‹å·® R çš„å«ä¹‰ï¼š                                                â”‚
â”‚   â”œâ”€â”€ â€–Râ€– å¤§ + R æœ‰ç»“æ„  â†’ æ–°çŸ¥è¯†ï¼Tagåº“éœ€è¦æ‰©å±•                  â”‚
â”‚   â”œâ”€â”€ â€–Râ€– å¤§ + R æ— ç»“æ„  â†’ å™ªå£°ï¼Œåº”è¯¥å¿½ç•¥                        â”‚
â”‚   â”œâ”€â”€ â€–Râ€– å° + å¤šTagå‘½ä¸­ â†’ è·¨åŸŸäº¤å‰ï¼ŒTagMemoæ ¸å¿ƒåœºæ™¯              â”‚
â”‚   â””â”€â”€ â€–Râ€– å° + å•Tagå‘½ä¸­ â†’ ç²¾å‡†æŸ¥è¯¢ï¼Œç›´æ¥å¬å›å³å¯                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ æ®‹å·®é‡‘å­—å¡”æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Residual Pyramid Module                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   Level 0: Q (åŸå§‹æŸ¥è¯¢å‘é‡)                                      â”‚
â”‚            â”‚                                                    â”‚
â”‚            â–¼ ä¸ Top-K Tags æ¡æ‰‹                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚ Î”â‚€ = {Q - Tagâ‚, Q - Tagâ‚‚, ..., Q - Tagâ‚–}              â”‚    â”‚
â”‚   â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚    â”‚
â”‚   â”‚      "æ¡æ‰‹å·®å€¼å‘é‡é›†"                                   â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚            â”‚                                                    â”‚
â”‚            â–¼ åˆæˆæŠ•å½±åˆ†é‡                                        â”‚
â”‚   Level 1: Pâ‚ = Î£ (w_i Ã— Tag_i)  (åŠ æƒTagä¸­å¿ƒ)                  â”‚
â”‚            Râ‚ = Q - Pâ‚           (ä¸€çº§æ®‹å·®)                     â”‚
â”‚            â”‚                                                    â”‚
â”‚            â–¼ Râ‚ å†æ¬¡æœç´¢ï¼ˆåœ¨æ®‹å·®ç©ºé—´æ‰¾è¡¥å……Tagï¼‰                   â”‚
â”‚   Level 2: Pâ‚‚ = Î£ (w_j Ã— Tag_j)  (è¡¥å……Tags)                    â”‚
â”‚            Râ‚‚ = Râ‚ - Pâ‚‚          (äºŒçº§æ®‹å·®)                     â”‚
â”‚            â”‚                                                    â”‚
â”‚            â–¼                                                    â”‚
â”‚   Level N: Râ‚™ = æœ€ç»ˆæ®‹å·® (ä¸å¯è§£é‡Šåˆ†é‡)                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ å®Œæ•´å®ç°

### 1. æ®‹å·®åˆ†ææ¨¡å—

```javascript
class ResidualPyramid {
    constructor(tagIndex, db, config = {}) {
        this.tagIndex = tagIndex;
        this.db = db;
        this.config = {
            maxLevels: config.maxLevels || 3,
            topK: config.topK || 10,
            residualThreshold: config.residualThreshold || 0.3,
            ...config
        };
    }

    /**
     * ğŸŒŸ æ ¸å¿ƒï¼šè®¡ç®—æŸ¥è¯¢å‘é‡çš„æ®‹å·®é‡‘å­—å¡”
     */
    analyze(queryVector) {
        const dim = queryVector.length;
        const pyramid = {
            levels: [],
            totalExplained: 0,      // è¢«Tagè§£é‡Šçš„æ€»èƒ½é‡
            finalResidual: null,    // æœ€ç»ˆæ®‹å·®
            features: {}            // æå–çš„ç‰¹å¾
        };

        let currentVector = new Float32Array(queryVector);
        let currentMagnitude = this._magnitude(currentVector);
        
        for (let level = 0; level < this.config.maxLevels; level++) {
            // æœç´¢å½“å‰å‘é‡çš„æœ€è¿‘Tags
            const searchBuffer = Buffer.from(currentVector.buffer);
            let tagResults;
            try {
                tagResults = this.tagIndex.search(searchBuffer, this.config.topK);
            } catch (e) {
                break;
            }
            
            if (tagResults.length === 0) break;

            // è·å–Tagè¯¦ç»†ä¿¡æ¯
            const tagIds = tagResults.map(r => r.id);
            const tags = this._getTagVectors(tagIds);
            
            // ğŸŒŸ è®¡ç®—æ¡æ‰‹å·®å€¼
            const handshakes = this._computeHandshakes(currentVector, tags, tagResults);
            
            // ğŸŒŸ è®¡ç®—æŠ•å½±å’Œæ®‹å·®
            const { projection, residual, weights } = this._computeProjectionAndResidual(
                currentVector, tags, tagResults
            );
            
            const residualMagnitude = this._magnitude(residual);
            const explainedRatio = 1 - (residualMagnitude / currentMagnitude);
            
            pyramid.levels.push({
                level,
                tags: tags.map((t, i) => ({
                    id: t.id,
                    name: t.name,
                    similarity: tagResults[i].score,
                    weight: weights[i],
                    handshakeMagnitude: handshakes.magnitudes[i],
                    handshakeDirection: handshakes.directions[i]
                })),
                projectionMagnitude: this._magnitude(projection),
                residualMagnitude,
                explainedRatio,
                // ğŸ†• æ¡æ‰‹ç‰¹å¾
                handshakeFeatures: this._analyzeHandshakes(handshakes)
            });
            
            pyramid.totalExplained += explainedRatio * currentMagnitude;
            
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥ç»§ç»­
            if (residualMagnitude < this.config.residualThreshold * currentMagnitude) {
                break; // æ®‹å·®è¶³å¤Ÿå°ï¼Œåœæ­¢
            }
            
            // ç”¨æ®‹å·®ä½œä¸ºä¸‹ä¸€çº§çš„è¾“å…¥
            currentVector = residual;
            currentMagnitude = residualMagnitude;
        }
        
        pyramid.finalResidual = currentVector;
        pyramid.features = this._extractPyramidFeatures(pyramid);
        
        return pyramid;
    }

    /**
     * ğŸŒŸ è®¡ç®—æ¡æ‰‹å·®å€¼ï¼ˆæŸ¥è¯¢ä¸æ¯ä¸ªTagçš„å·®å‘é‡ï¼‰
     */
    _computeHandshakes(query, tags, scores) {
        const dim = query.length;
        const n = tags.length;
        
        const deltas = [];        // å·®å‘é‡
        const magnitudes = [];    // å·®å‘é‡æ¨¡é•¿
        const directions = [];    // å·®å‘é‡æ–¹å‘ï¼ˆå½’ä¸€åŒ–ï¼‰
        
        for (let i = 0; i < n; i++) {
            const tagVec = new Float32Array(
                tags[i].vector.buffer, 
                tags[i].vector.byteOffset, 
                dim
            );
            
            // Î” = Q - Tag
            const delta = new Float32Array(dim);
            let mag = 0;
            for (let d = 0; d < dim; d++) {
                delta[d] = query[d] - tagVec[d];
                mag += delta[d] * delta[d];
            }
            mag = Math.sqrt(mag);
            
            deltas.push(delta);
            magnitudes.push(mag);
            
            // å½’ä¸€åŒ–æ–¹å‘
            const dir = new Float32Array(dim);
            if (mag > 1e-9) {
                for (let d = 0; d < dim; d++) {
                    dir[d] = delta[d] / mag;
                }
            }
            directions.push(dir);
        }
        
        return { deltas, magnitudes, directions };
    }

    /**
     * ğŸŒŸ åˆ†ææ¡æ‰‹å·®å€¼çš„ç»Ÿè®¡ç‰¹å¾
     */
    _analyzeHandshakes(handshakes) {
        const n = handshakes.magnitudes.length;
        if (n === 0) return null;
        
        const dim = handshakes.directions[0].length;
        
        // 1. å·®å€¼æ¨¡é•¿çš„ç»Ÿè®¡
        const magMean = handshakes.magnitudes.reduce((a, b) => a + b, 0) / n;
        const magVar = handshakes.magnitudes.reduce((sum, m) => 
            sum + (m - magMean) ** 2, 0) / n;
        
        // 2. å·®å€¼æ–¹å‘çš„ä¸€è‡´æ€§ï¼ˆæ‰€æœ‰å·®å‘é‡æ˜¯å¦æŒ‡å‘åŒä¸€æ–¹å‘ï¼Ÿï¼‰
        //    è®¡ç®—æ–¹å‘å‘é‡çš„å¹³å‡ï¼Œå…¶æ¨¡é•¿åæ˜ ä¸€è‡´æ€§
        const avgDirection = new Float32Array(dim);
        for (let i = 0; i < n; i++) {
            for (let d = 0; d < dim; d++) {
                avgDirection[d] += handshakes.directions[i][d] / n;
            }
        }
        const directionCoherence = this._magnitude(avgDirection);
        
        // 3. å·®å€¼å‘é‡ä¹‹é—´çš„äº’ç›¸å…³ï¼ˆæ˜¯å¦å½¢æˆæ¨¡å¼ï¼Ÿï¼‰
        let pairwiseSimilarity = 0;
        let pairCount = 0;
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                let dot = 0;
                for (let d = 0; d < dim; d++) {
                    dot += handshakes.directions[i][d] * handshakes.directions[j][d];
                }
                pairwiseSimilarity += Math.abs(dot);
                pairCount++;
            }
        }
        const avgPairwiseSim = pairCount > 0 ? pairwiseSimilarity / pairCount : 0;
        
        return {
            // å·®å€¼å¤§å°
            magnitudeMean: magMean,
            magnitudeStd: Math.sqrt(magVar),
            
            // å·®å€¼æ–¹å‘ä¸€è‡´æ€§ï¼šé«˜=æ‰€æœ‰Tagéƒ½"ç¼ºå¤±"åŒä¸€ä¸ªæ¦‚å¿µ
            directionCoherence,
            
            // å·®å€¼æ¨¡å¼æ€§ï¼šé«˜=å·®å€¼ä¹‹é—´æœ‰ç»“æ„
            patternStrength: avgPairwiseSim,
            
            // ğŸŒŸ å…³é”®æ´å¯ŸæŒ‡æ ‡
            // å¦‚æœæ–¹å‘ä¸€è‡´+æ¨¡å¼å¼º â†’ æŸ¥è¯¢åŒ…å«Tagåº“æœªè¦†ç›–çš„æ–°æ¦‚å¿µ
            noveltySignal: directionCoherence * (1 + avgPairwiseSim),
            
            // å¦‚æœæ–¹å‘ä¸ä¸€è‡´+æ¨¡å¼å¼± â†’ çº¯å™ªå£°
            noiseSignal: (1 - directionCoherence) * (1 - avgPairwiseSim)
        };
    }

    /**
     * è®¡ç®—æœ€ä¼˜æŠ•å½±å’Œæ®‹å·®
     */
    _computeProjectionAndResidual(query, tags, scores) {
        const dim = query.length;
        const n = tags.length;
        
        // ä½¿ç”¨ç›¸ä¼¼åº¦çš„softmaxä½œä¸ºæƒé‡
        const maxScore = Math.max(...scores.map(s => s.score));
        const expScores = scores.map(s => Math.exp((s.score - maxScore) * 5));
        const sumExp = expScores.reduce((a, b) => a + b, 0);
        const weights = expScores.map(e => e / sumExp);
        
        // åŠ æƒç»„åˆ
        const projection = new Float32Array(dim);
        for (let i = 0; i < n; i++) {
            const tagVec = new Float32Array(
                tags[i].vector.buffer,
                tags[i].vector.byteOffset,
                dim
            );
            for (let d = 0; d < dim; d++) {
                projection[d] += weights[i] * tagVec[d];
            }
        }
        
        // æ®‹å·® = åŸå‘é‡ - æŠ•å½±
        const residual = new Float32Array(dim);
        for (let d = 0; d < dim; d++) {
            residual[d] = query[d] - projection[d];
        }
        
        return { projection, residual, weights };
    }

    /**
     * ä»é‡‘å­—å¡”ä¸­æå–ç»¼åˆç‰¹å¾
     */
    _extractPyramidFeatures(pyramid) {
        if (pyramid.levels.length === 0) {
            return {
                depth: 0,
                coverage: 0,
                novelty: 1,
                coherence: 0,
                tagDiversity: 0
            };
        }

        const level0 = pyramid.levels[0];
        const handshake = level0.handshakeFeatures;
        
        // è¦†ç›–ç‡ï¼šè¢«Tagè§£é‡Šçš„èƒ½é‡æ¯”ä¾‹
        const coverage = pyramid.totalExplained;
        
        // æ–°é¢–åº¦ï¼šåŸºäºæ¡æ‰‹å·®å€¼çš„æ–°æ¦‚å¿µä¿¡å·
        const novelty = handshake ? handshake.noveltySignal : 0;
        
        // ç›¸å¹²åº¦ï¼šTagä¹‹é—´çš„è¯­ä¹‰ä¸€è‡´æ€§
        const tagScores = level0.tags.map(t => t.similarity);
        const scoreSpread = Math.max(...tagScores) - Math.min(...tagScores);
        const coherence = 1 - scoreSpread; // åˆ†æ•°è¶Šæ¥è¿‘ï¼Œç›¸å¹²åº¦è¶Šé«˜
        
        // Tagå¤šæ ·æ€§ï¼šå¬å›äº†å¤šå°‘ä¸åŒçš„Tag
        const uniqueTags = new Set();
        pyramid.levels.forEach(l => l.tags.forEach(t => uniqueTags.add(t.id)));
        const tagDiversity = uniqueTags.size / (this.config.topK * pyramid.levels.length);
        
        // ğŸŒŸ è·¨å±‚æ¨¡å¼ï¼šä¸åŒå±‚çº§æ˜¯å¦å¬å›äº†ä¸åŒçš„Tagï¼Ÿ
        let crossLayerNovelty = 0;
        for (let i = 1; i < pyramid.levels.length; i++) {
            const prevTags = new Set(pyramid.levels[i-1].tags.map(t => t.id));
            const newTags = pyramid.levels[i].tags.filter(t => !prevTags.has(t.id));
            crossLayerNovelty += newTags.length / pyramid.levels[i].tags.length;
        }
        crossLayerNovelty /= Math.max(1, pyramid.levels.length - 1);

        return {
            depth: pyramid.levels.length,
            coverage,
            novelty,
            coherence,
            tagDiversity,
            crossLayerNovelty,
            
            // ğŸŒŸ ç»¼åˆå†³ç­–æŒ‡æ ‡
            // TagMemoæ¿€æ´»å¼ºåº¦ï¼šé«˜è¦†ç›–+é«˜ç›¸å¹²+ä½å™ªå£° â†’ å¼ºæ¿€æ´»
            tagMemoActivation: coverage * coherence * (1 - (handshake?.noiseSignal || 0)),
            
            // è®°å¿†æ‰©å±•ä¿¡å·ï¼šé«˜æ–°é¢–åº¦+æœ‰ç»“æ„ â†’ åº”è¯¥å­¦ä¹ æ–°Tag
            expansionSignal: novelty * (1 - (handshake?.noiseSignal || 0))
        };
    }

    _getTagVectors(ids) {
        const placeholders = ids.map(() => '?').join(',');
        return this.db.prepare(`
            SELECT id, name, vector FROM tags WHERE id IN (${placeholders})
        `).all(...ids);
    }

    _magnitude(vec) {
        let sum = 0;
        for (let i = 0; i < vec.length; i++) {
            sum += vec[i] * vec[i];
        }
        return Math.sqrt(sum);
    }
}
```

---

## ğŸ”— æ•´åˆåˆ° TagMemo V3

```javascript
class KnowledgeBase {
    constructor() {
        // ...
        this.residualPyramid = new ResidualPyramid(this.tagIndex, this.db);
    }

    _applyTagBoostV3(vector, baseTagBoost) {
        const debug = true;
        
        // [1] æ®‹å·®é‡‘å­—å¡”åˆ†æ
        const pyramid = this.residualPyramid.analyze(vector);
        const features = pyramid.features;
        
        if (debug) {
            console.log(`[Residual] Depth: ${features.depth}, Coverage: ${features.coverage.toFixed(3)}`);
            console.log(`[Residual] Novelty: ${features.novelty.toFixed(3)}, Coherence: ${features.coherence.toFixed(3)}`);
            console.log(`[Residual] TagMemo Activation: ${features.tagMemoActivation.toFixed(3)}`);
            
            if (features.expansionSignal > 0.5) {
                console.log(`[Residual] âš ï¸ High novelty detected! Consider expanding Tag library.`);
            }
        }

        // [2] åŠ¨æ€è°ƒæ•´ TagBoost
        // æ ¸å¿ƒé€»è¾‘ï¼š
        //   - é«˜è¦†ç›–ç‡ + é«˜ç›¸å¹²åº¦ â†’ å¼ºåŒ–TagMemoï¼ˆä¿¡ä»»Tagç½‘ç»œï¼‰
        //   - é«˜æ–°é¢–åº¦ + ä½å™ªå£° â†’ é€‚åº¦TagMemoï¼ˆæ¢ç´¢æ€§å¬å›ï¼‰
        //   - é«˜å™ªå£° â†’ ç¦ç”¨TagMemoï¼ˆä¸è¦æ·»ä¹±ï¼‰
        
        const activationMultiplier = 0.5 + features.tagMemoActivation * 1.5;
        // èŒƒå›´: [0.5, 2.0]
        
        const effectiveTagBoost = baseTagBoost * Math.min(2.0, Math.max(0.3, activationMultiplier));
        
        // [3] ä½¿ç”¨é‡‘å­—å¡”ä¸­çš„Tagè¿›è¡Œå¢å¼º
        const allTags = [];
        pyramid.levels.forEach(level => {
            level.tags.forEach(t => {
                // æƒé‡ = åŸå§‹æƒé‡ Ã— å±‚çº§è¡°å‡
                const layerDecay = Math.pow(0.7, level.level);
                allTags.push({
                    ...t,
                    adjustedWeight: t.weight * layerDecay
                });
            });
        });
        
        // [4] æ„å»ºä¸Šä¸‹æ–‡å‘é‡ï¼ˆä½¿ç”¨æ¡æ‰‹å·®å€¼ä¿¡æ¯ï¼‰
        const contextVec = this._buildContextFromPyramid(vector, pyramid, allTags);
        
        // [5] èåˆ
        const dim = vector.length;
        const fused = new Float32Array(dim);
        for (let i = 0; i < dim; i++) {
            fused[i] = (1 - effectiveTagBoost) * vector[i] + effectiveTagBoost * contextVec[i];
        }
        
        // å½’ä¸€åŒ–
        let mag = 0;
        for (let i = 0; i < dim; i++) mag += fused[i] * fused[i];
        mag = Math.sqrt(mag);
        if (mag > 1e-9) {
            for (let i = 0; i < dim; i++) fused[i] /= mag;
        }
        
        return {
            vector: fused,
            info: {
                pyramidDepth: features.depth,
                coverage: features.coverage,
                novelty: features.novelty,
                activationMultiplier,
                matchedTags: allTags.map(t => t.name)
            }
        };
    }

    /**
     * ğŸŒŸ åˆ©ç”¨æ¡æ‰‹å·®å€¼æ„å»ºæ›´ç²¾å‡†çš„ä¸Šä¸‹æ–‡å‘é‡
     */
    _buildContextFromPyramid(query, pyramid, allTags) {
        const dim = query.length;
        const contextVec = new Float32Array(dim);
        
        if (pyramid.levels.length === 0) return query;
        
        const level0 = pyramid.levels[0];
        const handshake = level0.handshakeFeatures;
        
        // ç­–ç•¥é€‰æ‹©
        if (handshake && handshake.directionCoherence > 0.6) {
            // ğŸŒŸ æ¡æ‰‹æ–¹å‘ä¸€è‡´ï¼šå­˜åœ¨å…±åŒçš„"ç¼ºå¤±æ¦‚å¿µ"
            // ä¸ä»…ç”¨Tagä¸­å¿ƒï¼Œè¿˜è¦è¡¥å¿è¿™ä¸ªç¼ºå¤±æ–¹å‘
            
            let totalWeight = 0;
            allTags.forEach(t => {
                const tagVec = this._getTagVector(t.id);
                if (!tagVec) return;
                
                for (let d = 0; d < dim; d++) {
                    contextVec[d] += tagVec[d] * t.adjustedWeight;
                }
                totalWeight += t.adjustedWeight;
            });
            
            if (totalWeight > 0) {
                for (let d = 0; d < dim; d++) {
                    contextVec[d] /= totalWeight;
                }
            }
            
            // è¡¥å¿ç¼ºå¤±æ–¹å‘ï¼šå°†æ®‹å·®çš„ä¸€éƒ¨åˆ†åŠ å›æ¥
            const compensationStrength = handshake.directionCoherence * 0.3;
            const residual = pyramid.finalResidual;
            for (let d = 0; d < dim; d++) {
                contextVec[d] += residual[d] * compensationStrength;
            }
            
        } else {
            // æ™®é€šç­–ç•¥ï¼šçº¯TagåŠ æƒ
            let totalWeight = 0;
            allTags.forEach(t => {
                const tagVec = this._getTagVector(t.id);
                if (!tagVec) return;
                
                for (let d = 0; d < dim; d++) {
                    contextVec[d] += tagVec[d] * t.adjustedWeight;
                }
                totalWeight += t.adjustedWeight;
            });
            
            if (totalWeight > 0) {
                for (let d = 0; d < dim; d++) {
                    contextVec[d] /= totalWeight;
                }
            }
        }
        
        // å½’ä¸€åŒ–
        let mag = 0;
        for (let d = 0; d < dim; d++) mag += contextVec[d] * contextVec[d];
        mag = Math.sqrt(mag);
        if (mag > 1e-9) {
            for (let d = 0; d < dim; d++) contextVec[d] /= mag;
        }
        
        return contextVec;
    }
}
```

---

## ğŸ“Š æ®‹å·®ç‰¹å¾çš„å†³ç­–é€»è¾‘

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ®‹å·®é‡‘å­—å¡”å†³ç­–çŸ©é˜µ                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚                        è¦†ç›–ç‡ (Coverage)                        â”‚
â”‚                    ä½ (<0.3)        é«˜ (>0.7)                   â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚              â”‚                 â”‚                 â”‚              â”‚
â”‚     ä½       â”‚  âŒ ç¦ç”¨        â”‚  âš ï¸ æ¢ç´¢æ€§å¬å›   â”‚              â”‚
â”‚   (<0.3)     â”‚  (å™ªå£°+æœªçŸ¥)    â”‚  (å•ä¸€é¢†åŸŸæ·±æŒ–) â”‚              â”‚
â”‚              â”‚  TagBoost Ã—0.3 â”‚  TagBoost Ã—0.8 â”‚              â”‚
â”‚  æ–°          â”‚                 â”‚                 â”‚              â”‚
â”‚  é¢– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚
â”‚  åº¦          â”‚                 â”‚                 â”‚              â”‚
â”‚     é«˜       â”‚  ğŸ“š å­¦ä¹ ä¿¡å·    â”‚  ğŸŒŸ æœ€ä¼˜åœºæ™¯    â”‚              â”‚
â”‚   (>0.6)     â”‚  (æ–°æ¦‚å¿µå‡ºç°)   â”‚  (è·¨åŸŸå…±æŒ¯)    â”‚              â”‚
â”‚              â”‚  TagBoost Ã—0.6 â”‚  TagBoost Ã—1.5 â”‚              â”‚
â”‚              â”‚  +æ‰©å±•Tagåº“     â”‚  +å¼ºåŒ–å¬å›     â”‚              â”‚
â”‚              â”‚                 â”‚                 â”‚              â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   é¢å¤–æ¡ä»¶å åŠ :                                                  â”‚
â”‚   â€¢ æ–¹å‘ä¸€è‡´æ€§ > 0.6 â†’ è¡¥å¿æ®‹å·®æ–¹å‘ (+30%æ®‹å·®å›æ³¨)               â”‚
â”‚   â€¢ è·¨å±‚æ–°é¢–åº¦ > 0.5 â†’ å¤šå±‚å¬å›å¥–åŠ± (TagBoost Ã—1.2)              â”‚
â”‚   â€¢ æ¨¡å¼å¼ºåº¦ > 0.5 â†’ ç»“æ„åŒ–æŸ¥è¯¢å¥–åŠ± (TagBoost Ã—1.1)              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ è¿™ä¸ªæ–¹æ³•çš„æ·±å±‚ä»·å€¼

| ç‰¹å¾ | ä¼ ç»Ÿæ–¹æ³• | æ®‹å·®é‡‘å­—å¡”æ–¹æ³• |
|------|----------|----------------|
| **ä¿¡æ¯åˆ©ç”¨** | åªç”¨ç›¸ä¼¼åº¦åˆ†æ•° | åˆ©ç”¨å®Œæ•´çš„å·®å‘é‡ |
| **å¤šå±‚åˆ†æ** | å•æ¬¡å¬å› | é€’å½’åˆ†è§£ç›´åˆ°æ®‹å·®æ”¶æ•› |
| **æ–°çŸ¥è¯†æ£€æµ‹** | æ—  | é«˜æ–°é¢–åº¦+é«˜ç»“æ„=æ–°æ¦‚å¿µ |
| **å™ªå£°è¯†åˆ«** | ä¾èµ–é˜ˆå€¼ | æ–¹å‘ä¸ä¸€è‡´+æ— æ¨¡å¼=å™ªå£° |
| **è‡ªé€‚åº”æ€§** | å›ºå®šæƒé‡ | åŸºäºæ®‹å·®ç‰¹å¾åŠ¨æ€è°ƒæ•´ |

---

