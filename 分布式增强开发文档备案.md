# VCP 分布式插件兼容性分析与改进方案

您的理解基本正确，让我详细分析当前状态并提出完整的兼容方案：

## 当前兼容性状态总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        VCP 分布式插件兼容性矩阵                               │
├───────────────────────┬──────────┬──────────────────────────────────────────┤
│ 插件类型              │ 兼容性   │ 问题描述                                  │
├───────────────────────┼──────────┼──────────────────────────────────────────┤
│ synchronous           │ ✅ 100%  │ 完美工作，请求-响应模式天然适配 WebSocket  │
│ static                │ ✅ 100%  │ 已实现占位符推送机制                       │
│ asynchronous          │ ⚠️ 40%   │ 初始响应OK，回调机制断裂                   │
│ service               │ ⚠️ 60%   │ 路由只在本地可访问，无代理机制             │
│ hybridservice         │ ⚠️ 50%   │ 工具调用OK，路由+预处理有问题              │
│ messagePreprocessor   │ ❌ 0%    │ 完全不支持，无远程调用机制                 │
└───────────────────────┴──────────┴──────────────────────────────────────────┘
```

---

## 一、各类型详细问题分析

### 1. 同步插件 (synchronous) ✅

**工作流程（已完美实现）：**
```
主服务器 ──processToolCall──> WebSocketServer 
                                    │
                                    ▼
                         executeDistributedTool
                                    │
                                    ▼ (WebSocket)
                            分布式服务器
                                    │
                                    ▼
                         pluginManager.processToolCall
                                    │
                                    ▼
                           executePlugin (spawn)
                                    │
                                    ▼ (结果)
                            返回主服务器
```

### 2. 静态插件 (static) ✅

**工作流程（已完美实现）：**
```
分布式服务器:
    initializeStaticPlugins() 
         ↓
    定时执行 _executeStaticPluginCommand()
         ↓
    pushStaticPlaceholderValues() ──WebSocket──> 主服务器
                                                     ↓
                                        updateDistributedStaticPlaceholders()
                                                     ↓
                                        staticPlaceholderValues.set(key, {value, serverId})
```

### 3. 异步插件 (asynchronous) ⚠️

**问题所在：**
```javascript
// 主服务器 Plugin.js 中的异步插件处理
if (plugin.pluginType === 'asynchronous') {
    const callbackBaseUrl = pluginConfig.CALLBACK_BASE_URL || process.env.CALLBACK_BASE_URL;
    // ❌ 这个 URL 指向主服务器
    // ❌ 分布式服务器的异步插件回调无法路由回主服务器
    additionalEnv.CALLBACK_BASE_URL = callbackBaseUrl;
}
```

**断裂点：**
```
分布式异步插件执行完成
         ↓
回调到 CALLBACK_BASE_URL (分布式服务器本地)
         ↓
❌ 主服务器收不到回调通知
         ↓
❌ 用户无法获得最终结果
```

### 4. 服务插件 (service) ⚠️

**问题所在：**
```javascript
// 分布式服务器 VCPDistributedServer.js
await pluginManager.initializeServices(this.app, null, basePath);
// 服务插件的路由只注册到分布式服务器的 Express app
// 主服务器无法代理这些路由
```

**断裂点：**
```
用户请求 → 主服务器 /api/plugins/SomeService/endpoint
                          ↓
                    ❌ 404 Not Found
                    (路由在分布式服务器上，主服务器不知道)
```

### 5. 预处理器 (messagePreprocessor) ❌

**完全缺失的部分：**
```javascript
// 分布式服务器的 Plugin.js 完全没有预处理器支持
class PluginManager {
    constructor() {
        this.plugins = new Map();
        this.serviceModules = new Map();
        // ❌ 没有 messagePreprocessors
        // ❌ 没有 preprocessorOrder
    }
}
```

---

## 二、完整兼容方案设计

### 方案架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              主服务器                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         Plugin.js                                    │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │ 本地插件    │  │ 分布式插件   │  │ 统一调度器   │                  │   │
│  │  │ Map         │  │ Map         │  │             │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  │         ↓                ↓                ↓                         │   │
│  │  ┌──────────────────────────────────────────────────────────────┐  │   │
│  │  │              分布式执行引擎 (新增)                             │  │   │
│  │  │  • executeDistributedPreprocessor()                          │  │   │
│  │  │  • handleDistributedAsyncCallback()                          │  │   │
│  │  │  • proxyDistributedServiceRoute()                            │  │   │
│  │  └──────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    ↕ WebSocket                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                     ↕
┌─────────────────────────────────────────────────────────────────────────────┐
│                            分布式服务器                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Plugin.js (需增强)                                │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │ plugins     │  │preprocessors│  │ services    │  ← 新增          │   │
│  │  │ Map         │  │ Map         │  │ Map         │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  │  ┌──────────────────────────────────────────────────────────────┐  │   │
│  │  │              能力申报模块 (新增)                               │  │   │
│  │  │  • 申报可用的预处理器                                          │  │   │
│  │  │  • 申报服务路由端点                                            │  │   │
│  │  │  • 申报异步插件回调处理能力                                     │  │   │
│  │  └──────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 改进一：预处理器分布式支持 (最关键)

#### 1.1 分布式服务器 Plugin.js 增强

```javascript
// 分布式服务器 Plugin.js - 添加预处理器支持
class PluginManager {
    constructor() {
        this.plugins = new Map();
        this.serviceModules = new Map();
        this.staticPlaceholderValues = new Map();
        this.scheduledJobs = new Map();
        this.projectBasePath = null;
        this.debugMode = (process.env.DebugMode || "False").toLowerCase() === "true";
        
        // ========== 新增：预处理器支持 ==========
        this.messagePreprocessors = new Map();
        this.preprocessorOrder = [];
    }

    async loadPlugins() {
        console.log('[DistPluginManager] Starting plugin discovery...');
        this.plugins.clear();
        this.messagePreprocessors.clear(); // 新增

        const discoveredPreprocessors = new Map(); // 新增
        const modulesToInitialize = []; // 新增

        try {
            const pluginFolders = await fs.readdir(PLUGIN_DIR, { withFileTypes: true });
            for (const folder of pluginFolders) {
                if (folder.isDirectory()) {
                    const pluginPath = path.join(PLUGIN_DIR, folder.name);
                    const manifestPath = path.join(pluginPath, manifestFileName);
                    try {
                        const manifestContent = await fs.readFile(manifestPath, 'utf-8');
                        const manifest = JSON.parse(manifestContent);
                        if (!manifest.name || !manifest.pluginType || !manifest.entryPoint) continue;
                        if (this.plugins.has(manifest.name)) continue;
                        
                        manifest.basePath = pluginPath;
                        manifest.pluginSpecificEnvConfig = {};
                        try {
                            const pluginEnvContent = await fs.readFile(path.join(pluginPath, 'config.env'), 'utf-8');
                            manifest.pluginSpecificEnvConfig = dotenv.parse(pluginEnvContent);
                        } catch (envError) { /* ignore */ }

                        this.plugins.set(manifest.name, manifest);
                        console.log(`[DistPluginManager] Loaded manifest: ${manifest.displayName} (${manifest.name})`);

                        // ========== 新增：预处理器加载逻辑 ==========
                        const isPreprocessor = manifest.pluginType === 'messagePreprocessor' || 
                                              manifest.pluginType === 'hybridservice';
                        const isService = manifest.pluginType === 'service' || 
                                         manifest.pluginType === 'hybridservice';

                        if ((isPreprocessor || isService) && 
                            manifest.entryPoint.script && 
                            manifest.communication?.protocol === 'direct') {
                            try {
                                const scriptPath = path.join(pluginPath, manifest.entryPoint.script);
                                const module = require(scriptPath);
                                
                                modulesToInitialize.push({ manifest, module });

                                if (isPreprocessor && typeof module.processMessages === 'function') {
                                    discoveredPreprocessors.set(manifest.name, module);
                                    if (this.debugMode) {
                                        console.log(`[DistPluginManager] Discovered preprocessor: ${manifest.name}`);
                                    }
                                }
                                if (isService) {
                                    this.serviceModules.set(manifest.name, { manifest, module });
                                }
                            } catch (e) {
                                console.error(`[DistPluginManager] Error loading module for ${manifest.name}:`, e);
                            }
                        }
                        // ========== 结束新增 ==========

                    } catch (error) {
                        if (this.debugMode) console.error(`[DistPluginManager] Error loading plugin:`, error);
                    }
                }
            }

            // ========== 新增：注册预处理器 ==========
            this.preprocessorOrder = Array.from(discoveredPreprocessors.keys()).sort();
            for (const pluginName of this.preprocessorOrder) {
                this.messagePreprocessors.set(pluginName, discoveredPreprocessors.get(pluginName));
            }
            if (this.preprocessorOrder.length > 0) {
                console.log('[DistPluginManager] Available preprocessors: ' + this.preprocessorOrder.join(', '));
            }

            // 初始化模块
            for (const { manifest, module } of modulesToInitialize) {
                if (typeof module.initialize === 'function') {
                    try {
                        const config = this._getPluginConfig(manifest);
                        await module.initialize(config, {});
                    } catch (e) {
                        console.error(`[DistPluginManager] Error initializing ${manifest.name}:`, e);
                    }
                }
            }
            // ========== 结束新增 ==========

            console.log(`[DistPluginManager] Plugin discovery finished. Loaded ${this.plugins.size} plugins.`);
            await this.initializeStaticPlugins();
        } catch (error) {
            console.error(`[DistPluginManager] Error reading plugin directory:`, error);
        }
    }

    // ========== 新增：预处理器执行方法 ==========
    async executeMessagePreprocessor(pluginName, messages) {
        const processorModule = this.messagePreprocessors.get(pluginName);
        const pluginManifest = this.plugins.get(pluginName);
        
        if (!processorModule || !pluginManifest) {
            throw new Error(`[DistPluginManager] Preprocessor "${pluginName}" not found.`);
        }
        if (typeof processorModule.processMessages !== 'function') {
            throw new Error(`[DistPluginManager] Plugin "${pluginName}" has no processMessages function.`);
        }
        
        try {
            if (this.debugMode) console.log(`[DistPluginManager] Executing preprocessor: ${pluginName}`);
            const config = this._getPluginConfig(pluginManifest);
            return await processorModule.processMessages(messages, config);
        } catch (error) {
            console.error(`[DistPluginManager] Error in preprocessor ${pluginName}:`, error);
            return messages; // 出错时返回原始消息
        }
    }

    // 获取可用预处理器列表（供注册时使用）
    getAvailablePreprocessors() {
        return this.preprocessorOrder.map(name => {
            const manifest = this.plugins.get(name);
            return {
                name,
                displayName: manifest?.displayName || name,
                description: manifest?.description || ''
            };
        });
    }
    // ========== 结束新增 ==========
}
```

#### 1.2 分布式服务器注册协议增强

```javascript
// VCPDistributedServer.js - 增强注册协议
registerTools() {
    const manifests = pluginManager.getAllPluginManifests();
    
    const payload = {
        type: 'register_tools',
        data: {
            serverName: this.serverName,
            serverPort: this.port,  // 新增：用于路由代理
            tools: manifests,
            
            // ========== 新增：能力申报 ==========
            capabilities: {
                // 可用的预处理器
                preprocessors: pluginManager.getAvailablePreprocessors(),
                
                // 服务插件路由信息
                serviceRoutes: this.collectServiceRoutes(),
                
                // 异步插件列表
                asyncPlugins: manifests
                    .filter(m => m.pluginType === 'asynchronous')
                    .map(m => m.name)
            }
            // ========== 结束新增 ==========
        }
    };
    this.sendMessage(payload);
}

// 新增：收集服务路由信息
collectServiceRoutes() {
    const routes = [];
    for (const [name, serviceData] of pluginManager.serviceModules) {
        if (serviceData.manifest.hasApiRoutes) {
            routes.push({
                pluginName: name,
                basePath: `/api/plugins/${name}`,
                endpoints: this.extractEndpoints(serviceData.module) // 可选：提取具体端点
            });
        }
    }
    return routes;
}
```

#### 1.3 分布式服务器处理预处理器调用

```javascript
// VCPDistributedServer.js - 添加预处理器处理
async handleMainServerMessage(message) {
    try {
        const parsedMessage = JSON.parse(message);
        if (this.debugMode) console.log(`[${this.serverName}] Received:`, parsedMessage.type);

        switch (parsedMessage.type) {
            case 'execute_tool':
                await this.handleToolExecutionRequest(parsedMessage.data);
                break;
            
            // ========== 新增：预处理器调用 ==========
            case 'execute_preprocessor':
                await this.handlePreprocessorRequest(parsedMessage.data);
                break;
            // ========== 结束新增 ==========
        }
    } catch (e) {
        console.error(`[${this.serverName}] Error parsing message:`, e);
    }
}

// 新增：处理预处理器请求
async handlePreprocessorRequest(data) {
    const { requestId, pluginName, messages } = data;
    
    if (!requestId || !pluginName) {
        console.error(`[${this.serverName}] Invalid preprocessor request.`);
        return;
    }

    if (this.debugMode) {
        console.log(`[${this.serverName}] Executing preprocessor '${pluginName}' for request: ${requestId}`);
    }

    let responsePayload;
    try {
        const processedMessages = await pluginManager.executeMessagePreprocessor(pluginName, messages);
        responsePayload = {
            type: 'preprocessor_result',
            data: {
                requestId,
                status: 'success',
                messages: processedMessages
            }
        };
    } catch (error) {
        console.error(`[${this.serverName}] Preprocessor error:`, error.message);
        responsePayload = {
            type: 'preprocessor_result',
            data: {
                requestId,
                status: 'error',
                error: error.message,
                messages: messages  // 返回原始消息
            }
        };
    }

    this.sendMessage(responsePayload);
}
```

#### 1.4 主服务器 WebSocketServer 增强

```javascript
// WebSocketServer.js - 添加预处理器远程调用
class WebSocketServer {
    // ... 现有代码 ...
    
    // ========== 新增：执行分布式预处理器 ==========
    async executeDistributedPreprocessor(serverId, pluginName, messages) {
        const server = this.distributedServers.get(serverId);
        if (!server || server.ws.readyState !== WebSocket.OPEN) {
            throw new Error(`Distributed server ${serverId} is not connected.`);
        }

        const requestId = `preproc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingPreprocessorRequests.delete(requestId);
                reject(new Error(`Preprocessor ${pluginName} on ${serverId} timed out.`));
            }, 30000);

            this.pendingPreprocessorRequests.set(requestId, { resolve, reject, timeout });

            server.ws.send(JSON.stringify({
                type: 'execute_preprocessor',
                data: { requestId, pluginName, messages }
            }));
        });
    }

    handleDistributedServerMessage(serverId, message) {
        // ... 现有代码 ...
        
        switch (parsed.type) {
            // ... 现有 case ...
            
            // ========== 新增 ==========
            case 'preprocessor_result':
                this.handlePreprocessorResult(parsed.data);
                break;
        }
    }

    handlePreprocessorResult(data) {
        const { requestId, status, messages, error } = data;
        const pending = this.pendingPreprocessorRequests.get(requestId);
        
        if (!pending) return;
        
        clearTimeout(pending.timeout);
        this.pendingPreprocessorRequests.delete(requestId);
        
        if (status === 'success') {
            pending.resolve(messages);
        } else {
            pending.reject(new Error(error || 'Preprocessor execution failed'));
        }
    }
    // ========== 结束新增 ==========
}
```

#### 1.5 主服务器 Plugin.js 整合分布式预处理器

```javascript
// 主服务器 Plugin.js - 整合分布式预处理器到执行链

class PluginManager {
    constructor() {
        // ... 现有代码 ...
        this.distributedPreprocessors = new Map(); // 新增：存储分布式预处理器信息
    }

    // 新增：注册分布式预处理器
    registerDistributedPreprocessors(serverId, preprocessors) {
        for (const prep of preprocessors) {
            const key = `${serverId}:${prep.name}`;
            this.distributedPreprocessors.set(key, {
                serverId,
                name: prep.name,
                displayName: prep.displayName,
                description: prep.description
            });
            if (this.debugMode) {
                console.log(`[PluginManager] Registered distributed preprocessor: ${prep.name} from ${serverId}`);
            }
        }
    }

    // 修改：执行所有预处理器（包括分布式）
    async executeAllMessagePreprocessors(messages) {
        let processedMessages = messages;
        
        // 首先执行本地预处理器
        for (const pluginName of this.preprocessorOrder) {
            const processorModule = this.messagePreprocessors.get(pluginName);
            if (processorModule) {
                processedMessages = await this.executeMessagePreprocessor(pluginName, processedMessages);
            }
        }
        
        // 然后执行分布式预处理器
        // 注意：这里的顺序可以通过配置文件统一管理
        for (const [key, info] of this.distributedPreprocessors) {
            try {
                if (this.debugMode) {
                    console.log(`[PluginManager] Calling distributed preprocessor: ${info.name} on ${info.serverId}`);
                }
                processedMessages = await this.webSocketServer.executeDistributedPreprocessor(
                    info.serverId,
                    info.name,
                    processedMessages
                );
            } catch (error) {
                console.error(`[PluginManager] Distributed preprocessor ${info.name} failed:`, error.message);
                // 继续执行，不中断链
            }
        }
        
        return processedMessages;
    }

    // 清理分布式预处理器
    unregisterDistributedPreprocessors(serverId) {
        for (const [key] of this.distributedPreprocessors) {
            if (key.startsWith(`${serverId}:`)) {
                this.distributedPreprocessors.delete(key);
            }
        }
    }
}
```

---

### 改进二：异步插件回调代理

#### 2.1 分布式服务器添加回调处理

```javascript
// VCPDistributedServer.js - 添加异步回调代理
class DistributedServer {
    async initialize() {
        // ... 现有代码 ...
        
        // ========== 新增：设置异步回调代理路由 ==========
        this.app.post('/vcp/async-callback/:pluginName', async (req, res) => {
            await this.handleAsyncPluginCallback(req, res);
        });
    }

    async handleAsyncPluginCallback(req, res) {
        const { pluginName } = req.params;
        const callbackData = req.body;
        
        if (this.debugMode) {
            console.log(`[${this.serverName}] Received async callback for plugin: ${pluginName}`);
        }

        // 转发回调到主服务器
        const payload = {
            type: 'async_plugin_callback',
            data: {
                pluginName,
                callbackData,
                serverName: this.serverName
            }
        };
        
        this.sendMessage(payload);
        res.status(200).json({ status: 'callback_forwarded' });
    }
}
```

#### 2.2 分布式服务器 Plugin.js 修改环境变量

```javascript
// 分布式服务器 Plugin.js - 修改异步插件环境变量
async executePlugin(pluginName, inputData) {
    // ... 现有代码 ...
    
    const plugin = this.plugins.get(pluginName);
    
    // ========== 新增：异步插件回调 URL 指向本地代理 ==========
    if (plugin.pluginType === 'asynchronous') {
        // 回调到本地代理端点，由代理转发到主服务器
        envForProcess.CALLBACK_BASE_URL = `http://localhost:${this.localPort}/vcp/async-callback`;
        envForProcess.PLUGIN_NAME_FOR_CALLBACK = pluginName;
    }
    // ========== 结束新增 ==========
    
    // ... 继续执行 ...
}
```

#### 2.3 主服务器处理转发的回调

```javascript
// WebSocketServer.js - 处理分布式异步回调
handleDistributedServerMessage(serverId, message) {
    // ... 现有代码 ...
    
    switch (parsed.type) {
        // ========== 新增 ==========
        case 'async_plugin_callback':
            this.handleDistributedAsyncCallback(serverId, parsed.data);
            break;
    }
}

handleDistributedAsyncCallback(serverId, data) {
    const { pluginName, callbackData, serverName } = data;
    
    console.log(`[WebSocketServer] Received async callback from distributed server ${serverName} for plugin ${pluginName}`);
    
    // 触发本地的异步回调处理机制
    // 这需要与现有的异步回调处理逻辑对接
    if (this.asyncCallbackHandler) {
        this.asyncCallbackHandler(pluginName, callbackData, {
            isDistributed: true,
            serverId,
            serverName
        });
    }
}
```

---

### 改进三：服务插件路由代理

#### 3.1 主服务器添加代理路由

```javascript
// server.js 或 Plugin.js - 添加分布式服务代理
class PluginManager {
    // 存储分布式服务路由信息
    distributedServiceRoutes = new Map();

    registerDistributedServiceRoutes(serverId, serverPort, serverIPs, routes) {
        for (const route of routes) {
            this.distributedServiceRoutes.set(`${serverId}:${route.pluginName}`, {
                serverId,
                serverPort,
                serverIPs,  // 包含 localIPs 和 publicIP
                pluginName: route.pluginName,
                basePath: route.basePath
            });
        }
    }

    setupServiceProxy(app) {
        // 代理分布式服务请求
        app.use('/api/distributed/:serverId/:pluginName/*', async (req, res) => {
            const { serverId, pluginName } = req.params;
            const subPath = req.params[0];
            const routeKey = `${serverId}:${pluginName}`;
            
            const routeInfo = this.distributedServiceRoutes.get(routeKey);
            if (!routeInfo) {
                return res.status(404).json({ error: 'Distributed service not found' });
            }

            try {
                // 选择可用的 IP（优先局域网）
                const targetIP = routeInfo.serverIPs.localIPs[0] || routeInfo.serverIPs.publicIP;
                const targetUrl = `http://${targetIP}:${routeInfo.serverPort}${routeInfo.basePath}/${subPath}`;
                
                // 使用 http-proxy-middleware 或手动转发
                const response = await this.proxyRequest(targetUrl, req);
                res.status(response.status).send(response.data);
            } catch (error) {
                res.status(502).json({ error: `Proxy error: ${error.message}` });
            }
        });
    }

    async proxyRequest(targetUrl, originalReq) {
        const { default: fetch } = await import('node-fetch');
        const response = await fetch(targetUrl, {
            method: originalReq.method,
            headers: originalReq.headers,
            body: ['POST', 'PUT', 'PATCH'].includes(originalReq.method) 
                ? JSON.stringify(originalReq.body) 
                : undefined
        });
        return {
            status: response.status,
            data: await response.text()
        };
    }
}
```

---

### 改进四：统一的预处理器顺序管理

```javascript
// preprocessor_order.json - 支持分布式预处理器
{
    "order": [
        { "type": "local", "name": "LocalPreprocessor1" },
        { "type": "distributed", "serverId": "home-server", "name": "RemotePreprocessor1" },
        { "type": "local", "name": "LocalPreprocessor2" },
        { "type": "distributed", "serverId": "cloud-server", "name": "RemotePreprocessor2" }
    ],
    "fallbackBehavior": "skip",  // 分布式预处理器不可用时的行为: skip | error | useLocal
    "timeout": 30000
}
```

```javascript
// 主服务器 Plugin.js - 统一顺序管理
async loadPreprocessorOrder() {
    try {
        const orderContent = await fs.readFile(PREPROCESSOR_ORDER_FILE, 'utf-8');
        const orderConfig = JSON.parse(orderContent);
        
        this.unifiedPreprocessorOrder = orderConfig.order.map(item => ({
            ...item,
            available: item.type === 'local' 
                ? this.messagePreprocessors.has(item.name)
                : this.distributedPreprocessors.has(`${item.serverId}:${item.name}`)
        }));
        
        console.log('[PluginManager] Unified preprocessor order loaded.');
    } catch (error) {
        // 使用默认顺序
    }
}

async executeAllMessagePreprocessors(messages) {
    let processedMessages = messages;
    
    for (const item of this.unifiedPreprocessorOrder) {
        if (!item.available) {
            if (this.debugMode) console.log(`[PluginManager] Skipping unavailable preprocessor: ${item.name}`);
            continue;
        }
        
        try {
            if (item.type === 'local') {
                processedMessages = await this.executeMessagePreprocessor(item.name, processedMessages);
            } else {
                processedMessages = await this.webSocketServer.executeDistributedPreprocessor(
                    item.serverId, 
                    item.name, 
                    processedMessages
                );
            }
        } catch (error) {
            console.error(`[PluginManager] Preprocessor ${item.name} failed:`, error.message);
            // 根据 fallbackBehavior 决定是否继续
        }
    }
    
    return processedMessages;
}
```

---

## 三、实现优先级建议

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           实现优先级路线图                                   │
├───────────┬───────────────────────────────────────────────────────────────┤
│ 优先级    │ 功能                                                           │
├───────────┼───────────────────────────────────────────────────────────────┤
│ P0 紧急   │ 预处理器分布式支持                                              │
│           │ • 这是目前完全缺失的核心功能                                     │
│           │ • RAGDiaryPlugin、LightMemo 等依赖预处理器                      │
│           │ • 预计工作量：3-5天                                             │
├───────────┼───────────────────────────────────────────────────────────────┤
│ P1 高     │ 异步插件回调代理                                                │
│           │ • 长时间任务插件需要此功能                                       │
│           │ • 预计工作量：1-2天                                             │
├───────────┼───────────────────────────────────────────────────────────────┤
│ P2 中     │ 服务插件路由代理                                                │
│           │ • 可以先通过直接访问分布式服务器 IP 解决                         │
│           │ • 预计工作量：2-3天                                             │
├───────────┼───────────────────────────────────────────────────────────────┤
│ P3 低     │ 统一预处理器顺序管理                                            │
│           │ • 当前可用分开管理                                              │
│           │ • 预计工作量：1天                                               │
└───────────┴───────────────────────────────────────────────────────────────┘
```

---

## 四、总结

您的判断完全正确：

| 类型 | 现状 | 核心问题 |
|------|------|----------|
| 同步 | ✅ 完美 | 无 |
| 静态 | ✅ 完美 | 无 |
| 异步 | ⚠️ 残缺 | 回调链断裂，需要代理机制 |
| 服务 | ⚠️ 能用 | 路由只在本地，需要代理或直连 |
| 混合服务 | ⚠️ 50% | 工具调用OK，路由和预处理有问题 |
| **预处理器** | **❌ 完全不兼容** | **分布式服务器根本没有实现此功能** |

**最关键的改进是预处理器支持**，因为这是目前分布式服务器完全缺失的能力，而预处理器在 VCP 架构中扮演着非常重要的角色（消息增强、上下文注入、历史处理等）。