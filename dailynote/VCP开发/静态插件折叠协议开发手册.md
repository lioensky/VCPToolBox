# VCP 静态插件与动态折叠协议开发手册

静态插件 (Static Plugins) 是 VCP 系统中提供基础全局状态感知的重要组件。与需要 AI 显式调用的由 `PluginManager` 拉起的“同步/异步指令型插件”不同，静态插件在 VCP Server 启动时作为**常驻子进程**被挂载。它们通过向标准输出 (`stdout`) 周期性或一次性输出特定格式的文本字符串或结构化 JSON，无缝地将外部状态（如实时天气、当前系统资源甚至本地音乐播放进度等）注入到所有 Agent 的运行时系统提示词（System Prompt）中。

在 VCP 中，静态插件的占位符（如 `{{VCPWeatherInfo}}`）在用户每一次对话发给 LLM 前，都会被 `messageProcessor.js` 的 `replaceOtherVariables` 核心引擎自动解析并替换。

本文档将详细阐述静态插件的基础构建方式，并重点介绍 VCP 独创的 **“动态上下文语义折叠协议” (Contextual Folding Protocol)**。

---

## 1. 静态插件基础概念

静态插件设计的初衷是**零心智负担注入**。只要插件进程（位于 `Plugin` 目录下并提供有效的 `plugin-manifest.json`）向 `stdout` 输出内容，主控 Server (`Plugin.js`) 就捕获并将其缓存在内存字典（如 `staticPlaceholderValues`）中。

**基础运行模式:**

1.  **启动**: Server 根据 `plugin-manifest.json` 中 `"pluginType": "static"` 的声明，跟随主服务一同被拉起执行。
2.  **输出**: 插件脚本完成外部 API 调用或系统指令查询后，简单地将结果 `print()` (Python) 或 `console.log()` (Node.js) 出口。
3.  **解析替换**: Agent 系统提示词如书写了 `{{VCP你的插件名}}`，则被自动替换为最新缓存的 `stdout` 字符串。

### 1.1 基础实现 (纯文本输出模式)

**适用场景**: 系统时间、轻量级资源占用显示、单句口号或永远只需要极短文本的场景。

**示例实现 (Node.js)**:
```javascript
// Plugin/TimeAnnouncer/TimeAnnouncer.js
function main() {
    const now = new Date();
    // 纯文本输出，直接被当做 {{VCPTimeAnnouncer}} 替换值
    console.log(`当前系统服务器精确时间：${now.toISOString()}`);
    process.exit(0);
}
main();
```

---

## 2. 动态上下文语义折叠协议 (`vcp_dynamic_fold`)

> **痛点**: 一些静态插件（比如 7天天气、完整个人日程表、每日长篇简报）返回的文本量巨大。如果用户当前的话题是“写一段代码”或“闲聊”，将数百 Tokens 毫无关联的详实日程表塞入 System Prompt，既严重浪费金钱（Token开销），也可能干扰 LLM 的注意力导致幻觉（Latent Space Collapse / Attention Hijacking）。

为了解决这一痛点，VCP 实现了深度整合 RAG 语义模块的“**自适应展示协议 (`vcp_dynamic_fold`)**”。

### 2.1 核心原理

1.  静态插件不再输出一堆长文本，而是输出一段符合规范的 **JSON** 字符串。该 JSON 包含一个 `plugin_description` 和包含多个 `threshold` 的 `fold_blocks` 数组。
2.  VCP `KnowledgeBaseManager` 模块在首次侦测到这个配置时，会自动将 `plugin_description`（如“这是一个天气插件”）发送给内置架构的 Embedding 模型，**进行高维向量化（Vectorization）并持久化存入 SQLite 数据库**。
3.  当用户与 Agent 交流时，VCP Server 会提取用户最后一次发出的 Query（例如“明天带伞吗？”）并实时计算其语句向量。
4.  系统比对**用户 Query 向量**与**插件描述向量**的**余弦相似度 (Cosine Similarity)**，并根据匹配命中的阈值，智能展开对应的 `content` 内容进行替换注入！

### 2.2 协议数据结构与规范

当你的静态插件想要启用折叠功能时，必须向 `stdout` 打印具有以下解构的合法 JSON 字符串。

**示例实现 (WeatherReporter.js 概录):**

```javascript
  const outputObj = {
    // 【必选】此标志位激活核心解析器的语义匹配引擎
    vcp_dynamic_fold: true,
    
    // 【必选】用于被 RAG Embedding API 向量化的自然语言描述。
    // 请精准描述此插件的内容，这决定了语义命中的准确率。
    plugin_description: "天气预报插件，提供各个城市及地区的实时天气、未来数天预报、空气质量预警与生活日出日落太阳位置",
    
    // 【必选】信息密度区块数组 (必须包含 threshold 和 content 字段)
    // 建议按 threshold 降序排列。
    fold_blocks: [
      { 
        // 极高相关度：比如用户问 "下周旅游的天气如何"，命中 0.5+，展开长达百行的最全信息
        threshold: 0.5, 
        content: "【实时空气】...【未来预警】...【未来24小时预报详尽版】...【未来7日预报详尽版】...【日出日落及月相数据】..." 
      },
      { 
        // 中度相关度：比如用户问 "明天天气"，命中 0.35+，返回轻薄的3天预报
        threshold: 0.35, 
        content: "【实时概况】...【3日精简预报】..." 
      },
      { 
        // 完全无关/基准退回：比如用户问 "写一段Python"，命中的相似度可能是 0.05
        // VCP Core 会自动 Fallback 返回此兜底块的极短内容，以最精简形式保持存在感知
        threshold: 0.0, 
        content: "【实时概况】空气质量: 良 (AQI 60)。(今日无预警)" 
      }
    ]
  };

  // 输出给系统
  console.log(JSON.stringify(outputObj, null, 2));
```

### 2.3 `vcp_dynamic_fold` 处理流源码细节（进阶参考）

如果你正在调试自己的插件无法正确折叠，请了解 VCP Core Server (`modules/messageProcessor.js`) 处理你返回的 JSON 的内部机制：

1.  **安全解析**: `Plugin.js` 会尝试 `try...JSON.parse(stdout_string)`。一旦含有 `vcp_dynamic_fold`，它就会作为对象保留给消息处理器。如果抛错则回退当做普通常规文本字符串处理。 
2.  **向量缓存持久化 (`getPluginDescriptionVector`)**: VCP 依赖 `KnowledgeBaseManager.js` 的 `kv_store`。如果你修改了 `plugin_description`，其哈希值改变，系统才会重新请求一次大语言模型后台扣除 Token 重新建立向量。否则，一律**秒级从硬盘 SQLite 进行零消耗内存匹配读写。**
3.  **计算兜底回退 (Fallback)**: 系统引擎会自动寻找你 `fold_blocks` 组里阈值最低（通常是 `0.0`，位于排序数组末端的那个区块）。如果发生“数据库查不到”、“用户的文本被意外清空”、“RAGDiary系统突然挂掉”等极端情况，VCP 将确保系统不会崩溃断链，而是安全无感地将内容替换为该 Fallback Base 块兜底内容。

---

## 3. Best Practices (最佳实践建议)

1. **粒度划分要合理**：建议静态信息的 `fold_blocks` 至少维护三个层级。
   - `0.0`：极致浓缩。一行字能说明白的绝对不开两行。这是面对 90% 对话场景的静默底色。
   - `0.3`~`0.4`：实用摘要。包含近期最迫切需要被 LLM 摄取的核心内容（例如近期的三条日程、明天的天气）。
   - `0.5`~`0.6`：全量展开。倾注所有你能抓取到的详细属性，这只在用户精准发问时才释放，无需在意 Token 消耗，详尽准确至上。
2. **描述要拟人且精确**：`plugin_description` 要像写给理解能力一般的用户看的一样。如果用很多生僻缩写或缺乏使用场景的术语，Embedding 取得的向量可能难以与用户的白话随口询问匹配上高阈值。例如："展示当前播放的网易云音乐信息和进度" 高于 "Netease API stdout daemon wrapper"。
